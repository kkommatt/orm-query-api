{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ORM Query API","text":"<p>orm-query-api is a modern Python library for dynamically generating RESTful CRUD APIs from SQLAlchemy ORM models using FastAPI \u2014 complete with advanced query parsing, validation, and automatic serialization.  Its philosophy is to minimize boilerplate by providing a high-level interface that auto-generates routers and parses complex URI query strings, translating them into SQL expressions under the hood.  Developers define their models and (optionally) serializers once, and the library handles CRUD endpoints, query filtering, sorting, pagination, and nested relationships automatically.</p> <p>Core concepts include:</p> <ul> <li>Auto-generated routers: Create CRUD endpoints (<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>) for any SQLAlchemy model with one function call or via a central registry.</li> <li>Query-string syntax: Use a formal Lark-based grammar to filter, sort, offset, and limit results via a single <code>q=</code> parameter.</li> <li>Serialization: Define custom serializers (with <code>SerializerField</code>/<code>RelationField</code>) to control output names and nested relationships; by default, serializers can be auto-generated from models.</li> <li>Validation: Query parameters are parsed into an <code>ActionTree</code> (holding select fields, filters, sort, etc.) and validated against the serializer so that invalid fields or operators are caught before SQL execution.</li> </ul> <p>Features at a glance include:</p> <ul> <li>\u2705 Auto-generate CRUD endpoints for any SQLAlchemy model</li> <li>\u2705 Support for query-string filters, sorting, pagination, and nested relations</li> <li>\u2705 Typed input via Pydantic models (for <code>POST</code>/<code>PUT</code>/<code>PATCH</code>)</li> <li>\u2705 Response serialization using customizable serializers (with field aliasing)</li> <li>\u2705 Built-in query parsing (via Lark) and validation of fields/operators</li> <li>\u2705 Easily composable into any FastAPI app (just include the generated routers)</li> </ul> <p>Together, these features let you focus on your data model and business logic, while orm-query-api handles the repetitive REST API wiring and query logic for you.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":"<p>Q: How does performance scale with complex queries? A: orm-query-api constructs SQL queries that use JSON aggregation for nested relations. For simple queries, performance is comparable to writing equivalent SQLAlchemy queries by hand. However, deeply nested or very large result sets may be slower due to JSON construction (<code>group_concat</code> or similar). In practice, this is often acceptable for typical REST API use-cases, but be mindful of large data loads. There is no inherent caching or asynchronous DB layer, so consider database indexing and pagination for large tables.</p> <p>Q: Does it support async or SQLModel? A: Currently, the library is written around SQLAlchemy\u2019s synchronous ORM. The generated endpoints are defined as <code>async def</code>, but they use a synchronous session (<code>session = get_session()</code>) under the hood. True async SQL support (e.g. with an async engine or SQLModel) is on the roadmap. For now, if you need async, you would have to integrate your own async session management or wait for future versions.</p> <p>Q: Can I use SQLModel classes? A: SQLModel is built on top of SQLAlchemy, so in principle you could wrap a SQLModel in this library by treating it like a SQLAlchemy model. However, direct compatibility isn\u2019t officially provided yet. The roadmap mentions SQLModel compatibility as a planned feature. For now, you\u2019d need to ensure your SQLModel behaves like a SQLAlchemy Declarative model (i.e. having a <code>__table__</code> and relationships) and possibly write a custom serializer for it.</p> <p>Q: How do I debug a malformed <code>q=</code> query? A: If the <code>q</code> parameter has a syntax error or refers to unknown fields, the library will raise a <code>ValidationException</code> with details. For example, a missing parenthesis or unknown operator will trigger Lark to complain. Ensure your query matches the grammar (e.g. quotes around strings, proper commas, valid field names). Logging the exception message will usually point to the problem location in the query string.</p> <p>Q: What about filtering on related models? A: You can filter on nested relationships using dot syntax. For example, if <code>ToDo</code> has a relationship <code>user</code>, you could do <code>.filter(user.id=10)</code> or <code>.filter(user.name=\"Alice\")</code>. Internally, this causes a JOIN on the related table. Just ensure you included the relation in the select part (or use <code>users(id,name)</code> in the select) if you want to see those fields in the response.</p> <p>These FAQs cover common concerns. For any other questions, remember that orm-query-api is open-source (MIT license) and contributions are welcome. The library\u2019s GitHub repository contains more examples, issue tracking, and an evolving roadmap.</p>"},{"location":"advanced/grammar/","title":"Extending Grammar","text":""},{"location":"advanced/grammar/#query-grammar-and-parser","title":"Query Grammar and Parser","text":"<p>The formal grammar for the <code>q</code> parameter is defined in [<code>orm_query_api/parser/query_parser.py</code>], using Lark:</p> <pre><code>start: \"q\" \"=\" action_tree\n\naction_tree: \"(\" field (\",\" field)* \")\" \n             (\".\" filter_fn)? (\".\" offset_fn)? (\".\" limit_fn)? (\".\" order_fn)?\n\nfilter_fn: \"filter\" \"(\" nested_field FILTER_OP rvalue \")\"\norder_fn: \"order\" \"(\" nested_field \",\" SORT_ORDER \")\"\nlimit_fn: \"limit\" \"(\" NUMBER \")\"\noffset_fn: \"offset\" \"(\" NUMBER \")\"\n\n!field: \"!\" CNAME | CNAME | \"*\" | relation\nnested_field: CNAME (\".\" CNAME)*\nrelation: CNAME action_tree\n</code></pre> <ul> <li>Fields: <code>field</code> can be a simple column name, <code>*</code> (wildcard), a negation like <code>!password</code> (to exclude), or a relation.</li> <li>Nested fields: <code>nested_field</code> allows things like <code>user.address.city</code>.</li> <li>filter_fn: Filters take the form <code>filter(fieldOPvalue)</code>, e.g. <code>filter(age&gt;=30)</code>, <code>filter(name=\"Alice\")</code>.</li> <li>order_fn: Sorting like <code>order(created_at,desc)</code>.</li> <li>offset/limit: Simple numeric pagination.</li> </ul> <p>The parser (via <code>SelectQueryTransformer</code>) builds an <code>ActionTree</code> where each part of the query string populates fields, filters, sort, etc. To extend or modify the grammar, you could edit this Lark grammar string or wrap the transformer. For example, you could add new functions (like <code>search(...)</code>) by modifying the grammar and transformer in <code>query_parser.py</code>.</p> <p>Internally, once parsed, the <code>ActionTree</code> is validated in <code>orm_query_api/parser/query_validation.py</code> to ensure all referenced fields actually exist in the serializer, and then turned into SQL in <code>orm_query_api/parser/query_parse.py</code>. The library relies on standard JSON aggregation functions (<code>group_concat</code>, <code>json</code>, etc.) in SQL to return result sets as JSON arrays.</p> <p>A helpful debugging tip is that if you supply an invalid query string, <code>parse_query</code> will throw a <code>ValidationException</code> with a Lark error message, telling you where the syntax failed.</p>"},{"location":"advanced/serializers/","title":"Serializers","text":""},{"location":"advanced/serializers/#advanced","title":"Advanced","text":""},{"location":"advanced/serializers/#custom-serializers-and-field-aliasing","title":"Custom Serializers and Field Aliasing","text":"<p>You can fully customize how model fields appear in your API by writing your own serializer:</p> <ul> <li>Field aliasing: In <code>SerializerField(\"db_field\", \"alias\")</code>, the second argument is the key used in JSON. For example, <code>SerializerField(\"created_at\", \"creation_time\")</code> means the API will return <code>\"creation_time\": \"2023-01-01T...\"</code> rather than <code>\"created_at\"</code>.</li> <li>Excluding fields: Simply omit a field from <code>fields</code> to exclude it. (You can also exclude dynamically via the <code>!field</code> syntax in the query string, which inverts selection.)</li> <li>Nested relations: Use <code>RelationField(\"relation_name\", \"alias\")</code> and then query with e.g. <code>relation_name(id,name)</code> to retrieve sub-objects.</li> </ul> <p>Example of chaining serializers (using one serializer inside another) might be accomplished by manually invoking <code>get_serializer()</code> inside a custom serialize method, but the library\u2019s focus is on flat definitions of fields. If you need custom logic (e.g. computed fields), you can simply compute them in your Pydantic models or in FastAPI endpoint logic; orm-query-api is primarily about wiring existing model fields.</p>"},{"location":"getting-started/install/","title":"Installation","text":""},{"location":"getting-started/install/#getting-started","title":"Getting Started","text":""},{"location":"getting-started/install/#installation","title":"Installation","text":"<p>Install orm-query-api from PyPI with pip:</p> <pre><code>pip install orm-query-api\n</code></pre> <p>This package requires Python 3.9 or newer (as specified in its <code>pyproject.toml</code>) and works with FastAPI 0.110+, SQLAlchemy 2.0+, Pydantic 2.x, and Lark 1.1+. Its main dependencies (as of version 0.1.0) include FastAPI, SQLAlchemy, Pydantic, and Lark for parsing grammar. After installation, you can import its components into your FastAPI project.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":""},{"location":"getting-started/quickstart/#quick-start","title":"Quick Start","text":"<p>Below is a simple example of how to go from a SQLAlchemy model to a running API endpoint:</p> <ol> <li>Define your SQLAlchemy model (using any declarative base). For example:</li> </ol> <pre><code>import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime, func, Boolean, Date\nfrom sqlalchemy.orm import Mapped, relationship\nfrom orm_query_api.services.db_services import Base  # SQLAlchemy Base\nfrom typing import List\n\nclass ToDo(Base):\n    __tablename__ = \"todo\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    comment: Mapped[str] = Column(String, nullable=True, default=None)\n    created_at: Mapped[datetime.datetime] = Column(\n        DateTime(timezone=True), server_default=func.now()\n    )\n    priority: Mapped[int] = Column(Integer)\n    is_main: Mapped[bool] = Column(Boolean)\n    worker_fullname: Mapped[str] = Column(String)\n    due_date: Mapped[datetime.date] = Column(Date)\n    count: Mapped[int] = Column(Integer, default=1)\n    users: Mapped[List[\"User\"]] = relationship(\n        secondary=\"todo_user\", back_populates=\"todos\"\n    )\n</code></pre> <ol> <li>Define a Pydantic schema and serializer.  The Pydantic <code>BaseModel</code> is used for input validation (<code>POST</code>/<code>PUT</code>), while a <code>BaseSerializer</code> subclass lists the fields (and any nested relations) for output.  For example:</li> </ol> <pre><code>from pydantic import BaseModel\nimport datetime\nfrom typing import List\nfrom orm_query_api.services.serialization import BaseSerializer, SerializerField, RelationField\n\nclass ToDoPydantic(BaseModel):\n    comment: str | None = None\n    created_at: datetime.datetime\n    priority: int\n    is_main: bool = False\n    worker_fullname: str\n    due_date: datetime.date\n    count: int = 0\n    user_ids: List[int]\n\nclass ToDoSerializer(BaseSerializer):\n    model = ToDo\n    fields = [\n        SerializerField(\"id\", \"primary_key\"),\n        SerializerField(\"comment\", \"instruction\"),\n        SerializerField(\"created_at\", \"creation_time\"),\n        SerializerField(\"priority\", \"preference\"),\n        SerializerField(\"is_main\", \"is_principal\"),\n        SerializerField(\"worker_fullname\", \"worker\"),\n        SerializerField(\"due_date\", \"deadline\"),\n        SerializerField(\"count\", \"amount\"),\n        RelationField(\"users\", \"users\"),\n    ]\n</code></pre> <p>In this serializer, we assign custom aliases like <code>\"primary_key\"</code> for <code>id</code> or <code>\"deadline\"</code> for <code>due_date</code>, which will be the JSON keys in responses.  The <code>RelationField</code> indicates a relationship to include (e.g. <code>users</code>).</p> <ol> <li>Generate and include the router.  Use <code>generate_crud_router</code> to create a FastAPI <code>APIRouter</code> with CRUD endpoints for your model.  For example:</li> </ol> <pre><code>from fastapi import FastAPI\nfrom orm_query_api.routes import generate_crud_router\n\napp = FastAPI()\n\ntodo_router = generate_crud_router(\n    model=ToDo,\n    serializer=ToDoSerializer,\n    pydantic_model=ToDoPydantic,\n    prefix=\"todo\"\n)\napp.include_router(todo_router)\n</code></pre> <p>This creates endpoints like <code>GET /todo/</code>, <code>GET /todo/{id}</code>, <code>POST /todo/</code>, etc. The <code>q=</code> query-string syntax (shown below) can then be used on the list endpoint.</p> <p>With these steps, you have a working API: for example, <code>GET /todo/</code> will list ToDo items, and you can filter or sort them by using queries like <code>GET /todo/?q=(id,created_at).filter(created_at&gt;=2023-01-01).order(created_at,desc)</code>.</p>"},{"location":"reference/api/","title":"API Reference","text":""},{"location":"reference/api/#reference","title":"Reference","text":""},{"location":"reference/api/#modelregistry","title":"ModelRegistry","text":"<pre><code>class ModelRegistry:\n    registry: Dict[str, Dict]\n    router: APIRouter\n</code></pre> <p>The ModelRegistry class helps you register multiple models at once. Key methods:</p> <ul> <li><code>register_model(model, serializer_class=None, prefix=None, pydantic_model=None, auto_generate=False)</code>: Registers a model. If no <code>serializer_class</code> or <code>pydantic_model</code> is provided (or if <code>auto_generate=True</code>), the library auto-generates them via <code>create_schema_and_serializer</code>. The model is stored in <code>registry</code>, and an <code>APIRouter</code> is created with CRUD endpoints for that model (using <code>generate_crud_router</code>).</li> <li><code>register_all_routes(app: FastAPI)</code>: Includes the combined router into the given FastAPI app (i.e. <code>app.include_router(self.router)</code>).</li> </ul> <p>Internally, <code>ModelRegistry</code> maintains a single FastAPI <code>APIRouter</code> (in <code>self.router</code>) and merges each generated router into it.</p>"},{"location":"reference/api/#generate_crud_router","title":"generate_crud_router","text":"<pre><code>def generate_crud_router(model: Type, serializer: Type[BaseSerializer], prefix: str, pydantic_model: Type[BaseModel]) -&gt; APIRouter\n</code></pre> <p>The generate_crud_router function returns a FastAPI <code>APIRouter</code> for a given SQLAlchemy model. It creates the following endpoints under <code>/{prefix}</code>:</p> <ul> <li><code>GET /</code> \u2013 List items, using <code>q=</code> for filtering/sorting.</li> <li><code>GET /{item_id}</code> \u2013 Retrieve a single item by primary key (raises 404 if not found).</li> <li><code>POST /</code> \u2013 Create a new item, expecting a Pydantic body; commits to DB.</li> <li><code>PUT /{item_id}</code> \u2013 Replace an item (404 if not exists).</li> <li><code>PATCH /{item_id}</code> \u2013 Update an item partially (only provided fields).</li> <li><code>DELETE /{item_id}</code> \u2013 Delete an item (returns 204 on success).</li> </ul> <p>The list endpoint (<code>GET /</code>) uses <code>parse_query()</code> and <code>validate_query_options()</code> to apply the requested filters/sorting, then runs <code>get_all()</code> to return JSON.</p>"},{"location":"reference/api/#parse_query","title":"parse_query","text":"<pre><code>def parse_query(q: str) -&gt; ActionTree\n</code></pre> <p>Parses a raw query string (the part after <code>q=</code>) into an <code>ActionTree</code>. The grammar is LALR-based; <code>parse_query</code> wraps the Lark parser and transforms syntax errors into a <code>ValidationException</code>. For example, <code>parse_query(\"(id,name).filter(age&gt;=30)\")</code> returns an <code>ActionTree</code> with <code>select=[\"id\",\"name\"]</code> and a filter on <code>age</code>. Malformed queries will raise an exception with an error message.</p>"},{"location":"reference/api/#baseserializer","title":"BaseSerializer","text":"<pre><code>class BaseSerializer:\n    model: Any\n    fields: List[SerializerField]\n</code></pre> <p>To customize serialization, define a subclass of <code>BaseSerializer</code> for your model. Key points:</p> <ul> <li><code>model</code>: the SQLAlchemy model class this serializer is for.</li> <li><code>fields</code>: a list of <code>SerializerField</code> (or <code>RelationField</code>) objects defining which fields to output and their aliases.</li> <li><code>get_model_inspection()</code>: Returns SQLAlchemy metadata inspector for the model.</li> <li><code>get_db_field(db_field: str)</code>: Look up the actual <code>InstrumentedAttribute</code> (column) for a given field name.</li> <li><code>get_serializer_field(field_alias: str)</code>: Find the <code>SerializerField</code> by alias.</li> <li>Automatic registration: When you subclass <code>BaseSerializer</code>, it automatically registers itself in an internal registry (used by <code>get_serializer()</code>).</li> </ul>"},{"location":"reference/api/#serializerfield-and-relationfield","title":"SerializerField and RelationField","text":"<pre><code>class SerializerField:\n    def __init__(self, field: str, alias: Optional[str], type_: Optional[type] = None)\n</code></pre> <p>A SerializerField represents a single model field.</p> <ul> <li><code>field</code>: the actual attribute name on the SQLAlchemy model.</li> <li><code>alias</code>: (optional) the name to use in JSON output (defaults to the same as <code>field</code> if not provided).</li> <li><code>type_</code>: (optional) Python type of the field (not usually needed).</li> </ul> <pre><code>class RelationField(SerializerField):\n    ...\n</code></pre> <p>A RelationField is used for relationship fields (e.g. a <code>relationship</code> on the SQLAlchemy model). Use it in <code>fields</code> to include related objects. For example, <code>RelationField(\"users\", \"users\")</code> indicates including the <code>users</code> relation.</p> <p>Other utility functions:</p> <ul> <li><code>get_serializer(model_type)</code>: Returns the serializer class registered for a given model.</li> <li><code>get_prop_serializer(model_type, prop_name)</code>: Given a model and a relationship property name, returns the serializer for the related model.</li> </ul>"},{"location":"usage/query/","title":"Writing Queries","text":""},{"location":"usage/query/#querying-with-q-syntax","title":"Querying with <code>q=</code> Syntax","text":"<p>The library supports a powerful URI query syntax using a single <code>q</code> parameter. A typical query looks like:</p> <pre><code>GET /todo/?q=(id,priority,users).filter(priority&gt;=5,user_fullname=\"Alice\").order(created_at,asc).offset(10).limit(5)\n</code></pre> <p>This breaks down as follows:</p> <ul> <li> <p>Selection (<code>(...)</code>): Inside the parentheses you list fields to select. You can use <code>*</code> for all fields or prefixes like <code>!</code> to exclude (e.g. <code>!password</code>). You can also select nested relations, e.g. <code>users(id,name)</code> to include related users with only <code>id</code> and <code>name</code>.</p> </li> <li> <p>Filtering (<code>.filter(fieldOPvalue)</code>): Append <code>.filter(...)</code> with conditions. Supported operators include <code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>in</code>, <code>is_null</code>, <code>like</code>, and <code>ilike</code>. For example, <code>.filter(priority&gt;=5)</code> or <code>.filter(user_fullname=\"Alice\")</code>. You can filter on nested fields using dot syntax: e.g. <code>.filter(users.id=2)</code> filters todos whose related user has ID 2.</p> </li> <li> <p>Sorting (<code>.order(field,asc|desc)</code>): Use <code>.order(field,asc)</code> or <code>.order(field,desc)</code> to sort the results. E.g. <code>.order(created_at,desc)</code> for newest first.</p> </li> <li> <p>Pagination (<code>.offset()</code> and <code>.limit()</code>): Use <code>.offset(N)</code> to skip <code>N</code> records and <code>.limit(N)</code> to restrict the number of results.</p> </li> </ul> <p>The grammar (defined in code) enforces this structure. Under the hood, <code>parse_query(q_str)</code> (in <code>orm_query_api/parser/query_parser.py</code>) parses the string into an <code>ActionTree</code> object. This tree has attributes: <code>select</code> (list of fields or nested field specifiers), <code>filters</code> (list of <code>FilterAction</code>), <code>sort</code> (<code>SortAction</code>), <code>offset</code> (int), <code>limit</code> (int), and <code>relations</code> (a dict of nested <code>ActionTree</code> for related models). For example:</p> <ul> <li> <p>Given <code>q=(id,name,users(id,name)).filter(users.id=5,priority&gt;=10).order(name,asc).limit(20)</code>, the parser builds an <code>ActionTree</code> where:</p> </li> <li> <p><code>select = [\"id\", \"name\", \"users\"]</code> (with <code>users</code> having its own ActionTree specifying <code>select=[\"id\",\"name\"]</code> internally).</p> </li> <li><code>filters = [ FilterAction(field=NestedField([\"users\",\"id\"]), operator=InstrumentedAttribute.eq, value=5), FilterAction(field=\"priority\", operator=operator.ge, value=10) ]</code>.</li> <li><code>sort = SortAction(field=NestedField([\"name\"]), order=SortOrder.ASC)</code>.</li> <li><code>limit = 20</code>, <code>offset = None</code> (default 0).</li> </ul> <p>Each <code>FilterAction</code> holds a <code>field</code> (possibly nested, e.g. <code>NestedField([\"users\",\"id\"])</code>), an SQLAlchemy operator function (e.g. <code>operator.eq</code> for <code>=</code>), and the value. The library then translates this <code>ActionTree</code> into an actual SQLAlchemy query (via <code>get_all()</code>), including joins for any nested relations.</p> <p>Examples:</p> <ol> <li>Filter and sort example:</li> </ol> <pre><code>GET /todo/?q=(id,priority).filter(priority&gt;=5,worker_fullname=\"Alice\").order(created_at,desc)\n</code></pre> <ul> <li>Selects only <code>id</code> and <code>priority</code> fields of <code>ToDo</code>.</li> <li>Filters <code>priority &gt;= 5</code> AND <code>worker_fullname = \"Alice\"</code>.</li> <li> <p>Sorts by <code>created_at</code> descending.</p> </li> <li> <p>Nested query example:</p> </li> </ul> <pre><code>GET /todo/?q=(id,comment,users(id,name)).filter(users.id=3).offset(10).limit(5)\n</code></pre> <ul> <li>Selects <code>id</code>, <code>comment</code>, and a nested <code>users</code> relation with only <code>id</code> and <code>name</code>.</li> <li>Filters where a related <code>users.id</code> equals 3.</li> <li>Applies pagination (skip 10, take 5).</li> </ul> <p>The <code>parse_query</code> and subsequent validation ensure that only known fields (as defined in your serializer) and supported operators are used. Invalid syntax or unknown fields will raise a <code>ValidationException</code>.</p>"},{"location":"usage/register/","title":"Registering Models","text":""},{"location":"usage/register/#usage","title":"Usage","text":""},{"location":"usage/register/#registering-models","title":"Registering Models","text":"<p>There are two main ways to register models and set up routes:</p> <ul> <li> <p>Using <code>generate_crud_router</code> directly: As shown above, call <code>generate_crud_router(model, serializer, pydantic_model, prefix)</code> and include the returned router in your app. This is good for a few models or manual control.</p> </li> <li> <p>Using <code>ModelRegistry</code>: The <code>ModelRegistry</code> class lets you register multiple models and then include all routes at once. Example:</p> </li> </ul> <pre><code>from orm_query_api.registry import ModelRegistry\nfrom fastapi import FastAPI\n\napp = FastAPI()\nregistry = ModelRegistry()\n\n# Register a model; serializer and schema will be auto-generated if omitted\nregistry.register_model(model=ToDo, serializer_class=ToDoSerializer, pydantic_model=ToDoPydantic)\nregistry.register_all_routes(app)\n</code></pre> <p>Internally, <code>register_model</code> stores the model info and calls <code>generate_crud_router</code> with that model's info. You can supply a custom <code>prefix</code> or let it default to the lowercase model name. If you omit <code>serializer_class</code> or <code>pydantic_model</code>, the library can auto-generate a Pydantic schema and serializer using all model columns.</p> <ul> <li>Advanced options: When registering, you can pass a custom URL prefix (e.g. <code>prefix=\"tasks\"</code>) or a custom serializer. If <code>auto_generate=True</code> in <code>register_model</code>, it will ignore provided <code>serializer_class</code> and create fresh ones.  By default, the router includes all standard CRUD endpoints (list, retrieve, create, update, partial update, delete).</li> </ul> <p>Regardless of approach, the generated list endpoint (e.g. <code>GET /todo/</code>) automatically uses the <code>q=</code> query parameter: it calls <code>parse_query()</code>, validates with your serializer, then runs <code>get_all()</code> to return JSON data.</p>"}]}